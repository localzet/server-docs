export const pageTitle = 'Архитектура системы'

# Архитектура Localzet Server

Localzet Server представляет собой высокопроизводительный асинхронный event-driven сервер для PHP, построенный на принципах многопроцессорной обработки и неблокирующего I/O.

## Концептуальная архитектура

Localzet Server использует архитектуру **Master-Worker** с разделением ответственности между процессами:

```
┌─────────────────────────────────────────────────────────────┐
│                    Master Process                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │   Init       │  │   Monitor    │  │   Signal     │     │
│  │   System     │  │   Workers    │  │   Handler    │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                         │
           ┌─────────────┼─────────────┐
           │             │             │
    ┌──────▼─────┐ ┌────▼──────┐ ┌───▼──────┐
    │  Worker 1  │ │ Worker 2  │ │ Worker N │
    │            │ │           │ │          │
    │  ┌──────┐  │ │ ┌──────┐  │ │ ┌──────┐ │
    │  │ Event│  │ │ │ Event│  │ │ │ Event│ │
    │  │ Loop │  │ │ │ Loop │  │ │ │ Loop │ │
    │  └──────┘  │ │ └──────┘  │ │ └──────┘ │
    │            │ │           │ │          │
    │  ┌──────┐  │ │ ┌──────┐  │ │ ┌──────┐ │
    │  │Socket│  │ │ │Socket│  │ │ │Socket│ │
    │  │Accept│  │ │ │Accept│  │ │ │Accept│ │
    │  └──────┘  │ │ └──────┘  │ │ └──────┘ │
    └────────────┘ └───────────┘ └──────────┘
```

## Основные компоненты

### 1. Master Process (Мастер-процесс)

Мастер-процесс является координатором всей системы и выполняет следующие функции:

- **Инициализация системы**: Проверка окружения, загрузка конфигурации, создание слушающих сокетов
- **Управление процессами**: Создание и мониторинг дочерних процессов (workers)
- **Обработка сигналов**: Управление жизненным циклом через POSIX сигналы
- **Сбор статистики**: Агрегация метрик от всех worker процессов

**Характеристики:**
- Не обрабатывает клиентские запросы
- Работает в режиме мониторинга
- Поддерживает плавную перезагрузку без простоя сервиса

### 2. Worker Processes (Рабочие процессы)

Worker процессы — это дочерние процессы, которые фактически обрабатывают входящие соединения:

- **Обработка соединений**: Принятие и обработка TCP/UDP соединений
- **Event Loop**: Работа с событийным циклом для неблокирующего I/O
- **Выполнение бизнес-логики**: Обработка запросов через протоколы прикладного уровня
- **Управление памятью**: Изоляция памяти между процессами

**Ключевые особенности:**
- Полная изоляция памяти между процессами
- Независимая работа событийных циклов
- Автоматическое пересоздание при критических ошибках

### 3. Event Loop (Событийный цикл)

Event Loop — это ядро асинхронной обработки:

```
┌─────────────────────────────────────┐
│         Event Loop                  │
│                                     │
│  ┌──────────┐    ┌──────────────┐  │
│  │ Timers   │    │   Streams    │  │
│  │          │    │              │  │
│  │ - Delay  │    │ - Readable   │  │
│  │ - Repeat │    │ - Writable   │  │
│  └──────────┘    └──────────────┘  │
│                                     │
│  ┌──────────┐    ┌──────────────┐  │
│  │ Signals  │    │  Suspension  │  │
│  │          │    │              │  │
│  │ - SIGINT │    │ - Fiber      │  │
│  │ - SIGTERM│    │ - Coroutine  │  │
│  └──────────┘    └──────────────┘  │
│                                     │
└─────────────────────────────────────┘
```

**Поддерживаемые реализации:**

1. **Linux Event Loop** (по умолчанию для Unix)
   - Использует libuv, libev или libevent при наличии
   - Fallback на stream_select() если расширения недоступны
   - Оптимальная производительность на Unix-системах

2. **Windows Event Loop**
   - Адаптированная реализация для Windows
   - Использует stream_select() и Windows-специфичные API

3. **Swoole Event Loop**
   - Использует встроенный событийный цикл Swoole
   - Максимальная производительность при наличии расширения

4. **Swow Event Loop**
   - Современная реализация на базе Swow
   - Поддержка coroutines и fibers

## Многоуровневая архитектура протоколов

Localzet Server использует двухуровневую модель протоколов:

### Транспортный уровень (Transport Layer)

Отвечает за передачу данных по сети:

- **TCP** — надежная потоковая передача данных
- **UDP** — дейтаграммная передача без установки соединения
- **Unix Socket** — локальная межпроцессная коммуникация
- **SSL/TLS** — зашифрованная передача поверх TCP

### Прикладной уровень (Application Layer)

Определяет формат данных и правила их обработки:

- **HTTP/HTTPS** — стандартный веб-протокол
- **WebSocket** — двунаправленная коммуникация
- **Text** — текстовый протокол с разделителем
- **Frame** — фреймовая структура данных
- **Custom** — пользовательские протоколы

## Поток данных в системе

```
Клиент
  │
  │ TCP Connection
  ▼
┌─────────────────┐
│  Listening      │
│  Socket         │
└─────────────────┘
  │
  │ Accept Connection
  ▼
┌─────────────────┐
│  Event Loop     │
│  (Epoll/Select) │
└─────────────────┘
  │
  │ Data Available
  ▼
┌─────────────────┐
│  Transport      │
│  Protocol       │
│  (TCP/UDP)      │
└─────────────────┘
  │
  │ Raw Data
  ▼
┌─────────────────┐
│  Application    │
│  Protocol       │
│  (HTTP/WS/etc)  │
└─────────────────┘
  │
  │ Decoded Data
  ▼
┌─────────────────┐
│  Business       │
│  Logic          │
│  (onMessage)    │
└─────────────────┘
  │
  │ Response
  ▼
┌─────────────────┐
│  Protocol       │
│  Encoding       │
└─────────────────┘
  │
  │ Encoded Data
  ▼
┌─────────────────┐
│  Transport      │
│  Sending        │
└─────────────────┘
  │
  │ Send to Client
  ▼
Клиент
```

## Модель памяти

### Изоляция процессов

Каждый worker процесс имеет полностью изолированную память:

```
Master Process          Worker 1           Worker 2           Worker 3
┌─────────────┐      ┌──────────┐      ┌──────────┐      ┌──────────┐
│ Static Vars │      │Memory    │      │Memory    │      │Memory    │
│ Config      │      │Isolated  │      │Isolated  │      │Isolated  │
│ Monitoring  │      │          │      │          │      │          │
└─────────────┘      └──────────┘      └──────────┘      └──────────┘
     │                     │                 │                 │
     └─────────────────────┴─────────────────┴─────────────────┘
                  Shared Socket (SO_REUSEPORT)
```

### Управление соединениями

Каждое соединение хранится в памяти соответствующего worker процесса:

```php
Worker Process Memory:
├── $server->connections[id] → TcpConnection
│   ├── $sendBuffer    // Буфер отправки
│   ├── $recvBuffer    // Буфер приема
│   ├── $protocol      // Протокол прикладного уровня
│   └── $context       // Контекст соединения
└── Static cache
    ├── Request cache  // Кеш запросов
    └── Protocol cache // Кеш протоколов
```

## Масштабируемость

### Горизонтальное масштабирование

- **Многопроцессорность**: Каждый CPU core может обслуживать отдельный процесс
- **SO_REUSEPORT**: Распределение соединений между процессами на уровне ядра
- **Load Balancing**: Автоматическая балансировка через kernel

### Вертикальное масштабирование

- **Event-driven I/O**: Обработка тысяч соединений в одном процессе
- **Memory efficiency**: Минимальное потребление памяти на соединение
- **CPU optimization**: Эффективное использование процессорного времени

## Безопасность

### Изоляция процессов

- Каждый процесс работает независимо
- Критическая ошибка в одном процессе не влияет на другие
- Автоматическое восстановление после сбоев

### Управление привилегиями

- Возможность запуска worker процессов от непривилегированного пользователя
- Drop privileges после привязки к портам
- Изоляция от системных ресурсов

### Валидация данных

- Проверка всех входящих данных
- Ограничение размера пакетов
- Защита от переполнения буферов

## Производительность

### Ключевые оптимизации

1. **Zero-copy операции** где возможно
2. **Буферизация I/O** для минимизации системных вызовов
3. **Кеширование** парсированных данных
4. **Пул соединений** для повторного использования ресурсов
5. **Оптимизация памяти** через эффективные структуры данных

### Метрики производительности

- **Пропускная способность**: До сотен тысяч запросов в секунду
- **Латентность**: Микросекунды на обработку запроса
- **Параллельность**: Десятки тысяч одновременных соединений на процесс
- **Использование памяти**: Минимальные накладные расходы на соединение

<Button
    href="/architecture/process-model"
    variant="text"
    arrow="right"
    children="Детали модели процессов"
/>

